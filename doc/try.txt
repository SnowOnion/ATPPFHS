① homo
② 否定
③ 蕴含
④ hetero

1-2-1
    1-1-1 ①
        no more ①
        !1-!1-!1 ②_1
            !!1-!!1-!!1 ②_1
                ...
            !(1-1)-!(1-1)-!(1-1) ③_1_1-1
                !(!1-!1)-!(!1-!1)-!(!1-!1) ②_1
                    ...
        (1-1)-(1-1)-(1-1) ③_1_1-1
            (!1-!1)-(!1-!1)-(!1-!1) ②_1
                (!!1-!!1)-(!!1-!!1)-(!!1-!!1) ②_1
                    ...
            ((1-1)-(1-1))-((1-1)-(1-1))-((1-1)-(1-1)) ③_1_1-1
                ...
    !1-2-!1 ②_1
        !1-1-!1 ①
            !!1-!1-!!1 ②_1
                ...
        !!1-2-!!1 ②_1
            !!1-1-!!1 ①
            ...
        ...
    1-!2-1 ②_2
        1-!1-1 ①
            !1-!!1-!1 ②_1
                ...
    (1-1)-2-(1-1) ③_1_1-1
    // 公式模式库里的 1 ~> 1-2 的 2 是“泛指”：即其他“公式变元”；它可能和定理模式里的其他变元同名，也可能不同名。
    (1-2)-2-(1-2) ③_1_1-2
    (2-1)-2-(2-1) => (1-2)-1-(1-2) ③_1_2-1
    (2-2)-2-(2-2) => (1-1)-1-(1-1) ③_1_2-2
    // 再继续就要引入陌生变元惹
    // 3-2-3 没有意义，肯定重复 => 1-2-1 ④_1_3
    (1-3)-2-(1-3) 有意义 => (1-2)-3-(1-2)
    (3-1)-2-(3-1) 有意义 => (1-2)-3-(1-2) 不过如果替换前是 1，跟上面肯定重复
    // (3-3)-2-(3-3) 没有意义，肯定重复 => (1-1)-2-(1-1)
    
    1-(1-1)-1
    
    
我已经想去 incredible proof machine 里抠出这块儿功能了。不过，先造着吧。毕竟练习 Haskell 也是很大的。